
;;
;; Checks proposal body
;;

int check_proposal(cell proposal) {
    slice cs = proposal.begin_parse();
    int kind = cs~load_uint(32);
    int hasExtras = cs~load_int(1);
    if (hasExtras) {
        return false; ;; Not supported
    }

    ;; Transaction proposal
    if (kind == proposal::transaction()) {
        cs~load_msg_addr(); ;; Load target
        cs~load_coins(); ;; Load coins
        ;; Load maybe stateinit
        if (cs~load_int(1)) {
            cs~load_ref();
        }
        ;; Load maybe payload
        if (cs~load_int(1)) {
            cs~load_ref();
        }
        cs.end_parse();
        return true;
    }

    ;; Resolution proposal
    if (kind == proposal::resolution()) {
        return true;
    }

    ;; Destroy proposal
    if (kind == proposal::destroy()) {
        cs~load_msg_addr(); ;; Load target
        return true;
    }

    return false;
}

;;
;; Proposal execution
;; NOTE: execution silently fails on invalid proposal to mark proposal as executed instead of crashing transactions
;;       but execution fails if something is wrong
;;

() execute_proposal(cell proposal) impure {

    ;; Begin parsing
    slice cs = proposal.begin_parse();
    int kind = cs~load_uint(32);
    if (cs~load_int(1)) {
        cs~load_ref();
    }

    ;; Tansaction
    if (kind == proposal::transaction()) {

        ;; int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 011000 -> 0x18

        ;; Basic message
        slice to_addr = cs~load_msg_addr();
        int value = cs~load_coins();
        var msg = begin_cell()
            .store_uint(0x18, 6)
            .store_slice(to_addr)
            .store_coins(value)
            .store_uint(0, 1 + 4 + 4 + 64 + 32);

        ;; State init
        if (cs~load_int(1)) {
            var stateInit = cs~load_ref();
            msg = msg.store_uint(1, 1);
            msg = msg.store_ref(stateInit);
        } else {
            msg = msg.store_uint(0, 1);
        }

        ;; Payload
        if (cs~load_int(1)) {
            var payload = cs~load_ref();
            msg = msg.store_uint(1, 1);
            msg = msg.store_ref(payload);
        } else {
            msg = msg.store_uint(0, 1);
        }

        ;; Send message
        send_raw_message(msg.end_cell(), 2);
    }

    ;; Destroy contract
    if (kind == proposal::destroy()) {

        ;; Create destroy message
        ;; int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 010000 -> 0x10
        slice to_addr = cs~load_msg_addr();
        var msg = begin_cell()
            .store_uint(0x10, 6)
            .store_slice(to_addr)
            .store_coins(0)
            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1);

        ;; Send message
        send_raw_message(msg.end_cell(), 32 + 128);
    }
}