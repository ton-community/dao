;; Commands
int op::proposal() asm "3241702467 PUSHINT";
int op::proposal::ok() asm "2391675301 PUSHINT";
int op::proposal::failed() asm "3508280713 PUSHINT";

int op::vote() asm "3047515073 PUSHINT";
int op::vote::ok() asm "1127259026 PUSHINT";
int op::vote::failed() asm "3486613244 PUSHINT";

int op::execute() asm "2483002579 PUSHINT";
int op::execute::ok() asm "2514550856 PUSHINT";
int op::execute::failed() asm "2163078063 PUSHINT";

;; Proposals
int proposal::transaction() asm "1225918510 PUSHINT";

;; Errors
int error::invalid_address() asm "70 PUSHINT";
int error::invalid_message() asm "72 PUSHINT";
int error::access_denied() asm "73 PUSHINT";
int error::internal_error() asm "74 PUSHINT";
int error::too_low_value() asm "76 PUSHINT";
int error::no_voting_power() asm "77 PUSHINT";

;;
;; Basic workchain addresses
;;

int parse_work_addr(slice cs) {
  (int sender_wc, slice sender_addr) = parse_var_addr(cs);
  throw_unless(error::invalid_address(), 0 == sender_wc);
  return sender_addr~load_uint(256);
}

(slice) serialize_work_addr(int addr) {
   return (begin_cell()
     .store_uint(2, 2)  ;; Is std address
     .store_uint(0, 1)  ;; Non-unicast
     .store_uint(0, 8)  ;; Basic workchain
     .store_uint(addr, 256) ;; Address hash
   ).end_cell().begin_parse();
}

;;
;; Custom Commands
;;

builder store_coins(builder b, int x) asm "STGRAMS";
(slice, int) load_coins(slice s) asm( -> 1 0) "LDGRAMS";

global int ctx_version;
global cell ctx_members;
global cell ctx_proposals;
global int ctx_total_shares;
global int ctx_allocated_shares;
global int ctx_total_members;
global int ctx_seq_proposal;

() load_base_data() impure {
    var ds = get_data().begin_parse();
    ctx_version = ds~load_uint(16);
    ctx_total_shares = ds~load_uint(32);
    ctx_allocated_shares = ds~load_uint(32);
    ctx_seq_proposal = ds~load_uint(64);
    ctx_total_members = ds~load_uint(32);
    ctx_members = ds~load_ref();
    ctx_proposals = ds~load_ref();
    ds.end_parse();
}

() store_base_data() impure {
    set_data(begin_cell()
        .store_uint(ctx_version, 16)
        .store_uint(ctx_total_shares, 32)
        .store_uint(ctx_allocated_shares, 32)
        .store_uint(ctx_seq_proposal, 64)
        .store_uint(ctx_total_members, 32)
        .store_ref(ctx_members)
        .store_ref(ctx_proposals)
    .end_cell());
}

global int ctx_member;
global int ctx_member_exist;
global int ctx_member_shares;

slice load_member_slice(slice cs) impure {
    ctx_member_shares = cs~load_coins();
    return cs;
}

() load_member(int member) impure {
    var (cs, found) = ctx_members.udict_get?(256, member);
    ctx_member = member;
    if (found) {
        cs = load_member_slice(cs);
        cs.end_parse();
        ctx_member_exist = true;
    } else {
        ctx_member_shares = 0;
        ctx_member_exist = false;
    }
}

() store_member() impure {
    var shouldExist = (ctx_member_shares > 0);
    if ((~ shouldExist) & ctx_member_exist) {
        
        ;; Compiler crashes when single lined
        var (changed, _) = udict_delete?(ctx_members, 256, ctx_member);
        ctx_members = changed;

    } elseif (shouldExist) {

        var data = begin_cell()
            .store_coins(ctx_member_shares);
        
        ;; Compiler crashes when single lined
        var changed = udict_set_builder(ctx_members, 256, ctx_member, data);
        ctx_members = changed;
    }
}



;;
;; Check proposal body
;;

int check_proposal(cell proposal) {
    slice cs = proposal.begin_parse();
    int kind = cs~load_uint(32);
    if (kind == proposal::transaction()) {
        cs~load_msg_addr(); ;; Load target
        cs~load_coins(); ;; Load coins
        cs.end_parse();
        return true;
    } else {
        return false;
    }
}

() register_proposal(int seq, cell proposal, int member) {

    ;; Check seq
    throw_unless(seq == ctx_seq_proposal, error::invalid_message());

    ;; Default vote
    cell votes = null();
    votes~udict_set_builder(member, 256, begin_cell().store_int(true, 1).store_coins(ctx_member_shares));

    ;; Create proposal container
    builder container = begin_cell()
        .store_uint(0, 2) ;; State
        .store_coins(ctx_member_shares) ;; Voted yes
        .store_coins(0) ;; Voted no
        .store_coins(0) ;; Voted any
        .store_uint(member, 256) ;; Author
        .store_ref(votes)
        .store_ref(proposal);

    ;; Register proposal
    cell changed = udict_set_builder(ctx_proposals, 32, seq, container);
    ctx_proposals = changed;
}

() op_proposal(int member, int value, slice in_msg) impure {

    ;; Check input
    throw_unless(error::no_voting_power(), ctx_member_shares > 0);
    int seq = in_msg~load_uint(32);
    cell proposal = in_msg~load_ref();
    in_msg.end_parse();
    throw_unless(error::invalid_message(),check_proposal(proposal));

    ;; Register input
    register_proposal(seq, proposal, member);
}

() op_vote(int member, int value, slice in_msg) impure {
    throw_unless(error::no_voting_power(), ctx_member_shares > 0);
}

() op_execute(int member, int value, slice in_msg) impure {
    throw_unless(error::no_voting_power(), ctx_member_shares > 0);
}

() recv_internal(int msg_value, cell in_msg_cell, slice in_msg) impure {
    ;; Prepare message context
    var cs = in_msg_cell.begin_parse();
    var flags = cs~load_uint(4);  ;; int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool
    slice s_addr = cs~load_msg_addr();
    (int sender_wc, slice sender_addr) = parse_var_addr(cs);

    ;; Bounced
    ;; DAO accepts all bounced messages in case of invalid 
    ;; message was sent by DAO
    if (flags & 1) {
        return ();
    }

    ;; Ignore messages from non-workchain
    if (sender_wc != 0) {
        return ();
    }

    ;; Load base data
    int member = sender_addr~load_uint(256);
    load_base_data();
    load_member(member);

    ;; Ignore invalid operations
    if (in_msg.slice_bits() < 32) {
        return ();
    }

    ;; Parse operation
    int op = in_msg~load_uint(32);
    if (op == op::proposal()) {
        op_proposal(member, msg_value, in_msg);
        return ();
    }
    if (op == op::vote()) {
        op_vote(member, msg_value, in_msg);
        return ();
    }
    if (op == op::execute()) {
        op_execute(member, msg_value, in_msg);
        return ();
    }

    ;; Ignore all invalid operations since DAO could vote to return coins to sender
    return ();
}

() recv_external(slice in_msg) impure {
    ;; Do not accept external messages
    throw(error::invalid_message());
}

