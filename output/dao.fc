;; Commands
int op::proposal() asm "3241702467 PUSHINT";
int op::proposal::ok() asm "2391675301 PUSHINT";
int op::proposal::failed() asm "3508280713 PUSHINT";

int op::vote() asm "3047515073 PUSHINT";
int op::vote::ok() asm "1127259026 PUSHINT";
int op::vote::failed() asm "3486613244 PUSHINT";

int op::execute() asm "2483002579 PUSHINT";
int op::execute::ok() asm "2514550856 PUSHINT";
int op::execute::failed() asm "2163078063 PUSHINT";

;; Proposals
int proposal::transaction() asm "1225918510 PUSHINT";
int proposal::resolution() asm "3070113962 PUSHINT";
int proposal::destroy() asm "1738944794 PUSHINT";
int proposal::upgrade() asm "2894775163 PUSHINT";

;; Errors
int error::invalid_address() asm "70 PUSHINT";
int error::invalid_message() asm "72 PUSHINT";
int error::access_denied() asm "73 PUSHINT";
int error::internal_error() asm "74 PUSHINT";
int error::too_low_value() asm "76 PUSHINT";
int error::no_voting_power() asm "77 PUSHINT";

;; State
int vote::yes() asm "1 PUSHINT";
int vote::no() asm "0 PUSHINT";
int vote::abstain() asm "2 PUSHINT";

int state::pending() asm "0 PUSHINT";
int state::success() asm "1 PUSHINT";
int state::failure() asm "2 PUSHINT";
int state::executed() asm "3 PUSHINT";

;;
;; Basic workchain addresses
;;

int parse_work_addr(slice cs) {
  (int sender_wc, slice sender_addr) = parse_var_addr(cs);
  throw_unless(error::invalid_address(), 0 == sender_wc);
  return sender_addr~load_uint(256);
}

(slice) serialize_work_addr(int addr) {
   return (begin_cell()
     .store_uint(2, 2)  ;; Is std address
     .store_uint(0, 1)  ;; Non-unicast
     .store_uint(0, 8)  ;; Basic workchain
     .store_uint(addr, 256) ;; Address hash
   ).end_cell().begin_parse();
}

;;
;; Custom Commands
;;

builder store_coins(builder b, int x) asm "STGRAMS";
(slice, int) load_coins(slice s) asm( -> 1 0) "LDGRAMS";
builder store_builder(builder to, builder what) asm(what to) "STB";
builder store_builder_ref(builder to, builder what) asm(what to) "STBREFR";

;;
;; Message operations
;;

() send_std_message(
  slice to_addr,
  int value,
  int mode, 
  int op, 
  int query_id,
  builder content
) impure {

  var body = begin_cell()
      .store_uint(op, 32)
      .store_uint(query_id, 64)
      .store_builder(content)
  .end_cell();

  var msg = begin_cell()
    .store_uint(0x10, 6)
    .store_slice(to_addr)
    .store_coins(value)
    .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)
    .store_ref(body)
  .end_cell();

  send_raw_message(msg, mode);
}

() send_empty_std_message(
  slice to_addr,
  int value,
  int mode, 
  int op, 
  int query_id
) impure {

  var body = begin_cell()
      .store_uint(op, 32)
      .store_uint(query_id, 64)
  .end_cell();

  var msg = begin_cell()
    .store_uint(0x10, 6)
    .store_slice(to_addr)
    .store_coins(value)
    .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)
    .store_ref(body)
  .end_cell();

  send_raw_message(msg, mode);
}

() send_receipt_message(
  int to_addr,
  int op, 
  int query_id,
  builder content
) impure {
  send_std_message(serialize_work_addr(to_addr), 0, 64, op, query_id, content);
}

() send_empty_receipt_message(
  int to_addr,
  int op, 
  int query_id
) impure {
  send_empty_std_message(serialize_work_addr(to_addr), 0, 64, op, query_id);
}

global int ctx_version;
global int ctx_code_version;

global int ctx_members_shares_total;
global int ctx_members_shares_allocated;
global int ctx_members_total;
global cell ctx_members_dict;

global int ctx_proposals_seq;
global cell ctx_proposals_dict;
global cell ctx_proposals_ids;

() load_base_data() impure {

    ;; Parse root
    var ds = get_data().begin_parse();
    ctx_version = ds~load_uint(16);
    ctx_code_version = ds~load_uint(16);
    cell membersRef = ds~load_ref();
    cell proposalsRef = ds~load_ref();
    ds.end_parse();

    ;; Parse members
    ds = membersRef.begin_parse();
    ctx_members_shares_total = ds~load_uint(32);
    ctx_members_shares_allocated = ds~load_uint(32);
    ctx_members_total = ds~load_uint(32);
    ctx_members_dict = ds~load_ref();
    ds.end_parse();

    ;; Parse proposals
    ds = proposalsRef.begin_parse();
    ctx_proposals_seq = ds~load_uint(32);
    ctx_proposals_dict = ds~load_dict();
    ctx_proposals_ids = ds~load_dict();
    ds.end_parse();
}

() store_base_data() impure {
    set_data(begin_cell()
        .store_uint(ctx_version, 16)
        .store_uint(ctx_code_version, 16)
        .store_ref(begin_cell()
            .store_uint(ctx_members_shares_total, 32)
            .store_uint(ctx_members_shares_allocated, 32)
            .store_uint(ctx_members_total, 32)
            .store_ref(ctx_members_dict)
        .end_cell())
        .store_ref(begin_cell()
            .store_uint(ctx_proposals_seq, 32)
            .store_dict(ctx_proposals_dict)
            .store_dict(ctx_proposals_ids)
        .end_cell())
    .end_cell());
}

;;
;; Members storage
;; NOTE: this storage have to store ONLY voting shares, do not add anything else here
;;       since it is copied furing proposal creation
;;


int load_shares(cell dict, int member) {
    var (cl, found) = ctx_members_dict.udict_get_ref?(256, member);
    if (found) {
        slice cs = cl.begin_parse();
        int coins = cs~load_coins();
        cs.end_parse();
        return coins;
    } else {
        return 0;
    }
}

cell store_shares(cell dict, int member, int shares) {
    if (shares > 0) {
        var data = begin_cell()
            .store_ref(begin_cell()
                .store_coins(shares)
            .end_cell());
        return udict_set_builder(dict, 256, member, data);
    } else {
        var (changed, _) = udict_delete?(dict, 256, member);
        return changed;
    }
}

global int ctx_proposal_id;
global int ctx_proposal_state;
global int ctx_proposal_voted_yes;
global int ctx_proposal_voted_no;
global int ctx_proposal_voted_abstain;

;; Params
global int ctx_proposal_author;
global int ctx_proposal_created;
global int ctx_proposal_treshold_success;
global int ctx_proposal_treshold_failure;
global cell ctx_proposal_metadata;

;; Votes
global cell ctx_proposal_votes;

;; Body
global cell ctx_proposal_body;

;; Members
global cell ctx_proposal_members;
global int ctx_proposal_members_total;
global int ctx_proposal_members_shares_total;
global int ctx_proposal_members_shares_allocated;

;;
;; Loading proposal
;;

() load_proposal(int id) impure {

    ;; Load proposal
    var (cl, found) = ctx_proposals_dict.udict_get_ref?(32, id);
    throw_unless(error::invalid_message(), found);
    var cs = cl.begin_parse();

    ;; Read
    ctx_proposal_id = id;
    throw_if(error::invalid_message(), cs~load_uint(1) != 0);
    ctx_proposal_state = cs~load_uint(4);
    ctx_proposal_voted_yes = cs~load_coins();
    ctx_proposal_voted_no = cs~load_coins();
    ctx_proposal_voted_abstain = cs~load_coins();
    cell params_cell = cs~load_ref();
    ctx_proposal_votes = cs~load_ref();
    ctx_proposal_body = cs~load_ref();
    cell members_cell = cs~load_ref();
    cs.end_parse();
    
    ;; Params
    cs = params_cell.begin_parse();
    ctx_proposal_author = cs~load_uint(256);
    ctx_proposal_created = cs~load_uint(32);
    ctx_proposal_treshold_success = cs~load_coins();
    ctx_proposal_treshold_failure = cs~load_coins();
    ctx_proposal_metadata = cs~load_ref();
    cs.end_parse();

    ;; Members
    cs = members_cell.begin_parse();
    ctx_proposal_members_shares_total = cs~load_coins();
    ctx_proposal_members_shares_allocated = cs~load_coins();
    ctx_proposal_members_total = cs~load_coins();
    ctx_proposal_members = cs~load_ref();
    cs.end_parse();
}

() store_proposal() impure {

    ;; Serialize proposal
    var container = begin_cell()
        .store_uint(0, 1)
        .store_uint(ctx_proposal_state, 4)
        .store_coins(ctx_proposal_voted_yes)
        .store_coins(ctx_proposal_voted_no)
        .store_coins(ctx_proposal_voted_abstain)
        .store_ref(begin_cell()
            .store_uint(ctx_proposal_author, 256)
            .store_uint(ctx_proposal_created, 32)
            .store_coins(ctx_proposal_treshold_success)
            .store_coins(ctx_proposal_treshold_failure)
            .store_ref(ctx_proposal_metadata)
        .end_cell())
        .store_ref(ctx_proposal_votes)
        .store_ref(ctx_proposal_body)
        .store_ref(begin_cell()
            .store_coins(ctx_proposal_members_shares_total)
            .store_coins(ctx_proposal_members_shares_allocated)
            .store_coins(ctx_proposal_members_total)
            .store_ref(ctx_proposal_members)
        .end_cell())
    .end_cell();

    ;; Store ref
    var data = begin_cell().store_ref(container);
    ctx_proposals_dict = udict_set_builder(ctx_proposals_dict, 32, ctx_proposal_id, data);
}


;;
;; Checks proposal body
;;

int check_proposal(cell proposal) {
    slice cs = proposal.begin_parse();
    int kind = cs~load_uint(32);

    ;; Transaction proposal
    if (kind == proposal::transaction()) {
        cs~load_msg_addr(); ;; Load target
        cs~load_coins(); ;; Load coins
        ;; Load maybe stateinit
        if (cs~load_int(1)) {
            cs~load_ref();
        }
        ;; Load maybe payload
        if (cs~load_int(1)) {
            cs~load_ref();
        }
        cs.end_parse();
        return true;
    }

    ;; Resolution proposal
    if (kind == proposal::resolution()) {
        return true;
    }

    ;; Destroy proposal
    if (kind == proposal::destroy()) {
        cs~load_msg_addr(); ;; Load target
        return true;
    }

    ;; Upgrade proposal
    if (kind == proposal::upgrade()) {
        cs~load_ref(); ;; Load code ref
    }

    return false;
}

;;
;; Proposal execution
;; NOTE: execution silently fails on invalid proposal to mark proposal as executed instead of crashing transactions
;;       but execution fails if something is wrong
;;

() execute_proposal(cell proposal) impure {

    ;; Begin parsing
    slice cs = proposal.begin_parse();
    int kind = cs~load_uint(32);

    ;; Tansaction
    if (kind == proposal::transaction()) {

        ;; int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 011000 -> 0x18

        ;; Basic message
        slice to_addr = cs~load_msg_addr();
        int value = cs~load_coins();
        var msg = begin_cell()
            .store_uint(0x18, 6)
            .store_slice(to_addr)
            .store_coins(value)
            .store_uint(0, 1 + 4 + 4 + 64 + 32);

        ;; State init
        if (cs~load_int(1)) {
            var stateInit = cs~load_ref();
            msg = msg.store_uint(1, 1);
            msg = msg.store_ref(stateInit);
        } else {
            msg = msg.store_uint(0, 1);
        }

        ;; Payload
        if (cs~load_int(1)) {
            var payload = cs~load_ref();
            msg = msg.store_uint(1, 1);
            msg = msg.store_ref(payload);
        } else {
            msg = msg.store_uint(0, 1);
        }

        ;; Send message
        send_raw_message(msg.end_cell(), 2);
    }

    ;; Destroy contract
    if (kind == proposal::destroy()) {

        ;; Create destroy message
        ;; int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 010000 -> 0x10
        slice to_addr = cs~load_msg_addr();
        var msg = begin_cell()
            .store_uint(0x10, 6)
            .store_slice(to_addr)
            .store_coins(0)
            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1);

        ;; Send message
        send_raw_message(msg.end_cell(), 32 + 128);
    }

    ;; Upgrade contract
    if (kind == proposal::upgrade()) {
        var newCode = cs~load_ref();
        set_code(newCode);
    }
}

;;
;; Tresholds
;;

int get_success_treshold(int total) {
    return (total * 51) / 100;
}

int get_failure_treshold(int total) {
    return (total * 25) / 100;
}

;;
;; Register proposal
;;

() register_proposal(int seq, cell proposal, cell metadata, int member) impure {

    ;; Load shares
    int shares = load_shares(ctx_members_dict, member);
    throw_unless(error::no_voting_power(), shares > 0);
    
    ;; Check seq
    throw_unless(error::invalid_message(), seq == ctx_proposals_seq);

    ;; Resolve state
    int state = state::pending();
    int treshold_success = get_success_treshold(ctx_members_shares_allocated);
    int treshold_failure = get_failure_treshold(ctx_members_shares_allocated);
    if (shares >= treshold_success) {
        state = state::success();
    }
    
    ;;
    ;; Prepare proposal data
    ;;

    ctx_proposal_id = seq;
    ctx_proposal_state = state;
    ctx_proposal_voted_yes = shares;
    ctx_proposal_voted_no = 0;
    ctx_proposal_voted_abstain = 0;

    ctx_proposal_author = member;
    ctx_proposal_created = now();
    ctx_proposal_treshold_success = treshold_success;
    ctx_proposal_treshold_failure = treshold_failure;
    ctx_proposal_metadata = metadata;

    cell votes = null();
    votes~udict_set_builder(256, member, begin_cell().store_uint(vote::yes(), 2));
    ctx_proposal_votes = votes;
    ctx_proposal_body = proposal;

    ctx_proposal_members = ctx_members_dict;
    ctx_proposal_members_total = ctx_members_total;
    ctx_proposal_members_shares_total = ctx_members_shares_total;
    ctx_proposal_members_shares_allocated = ctx_members_shares_allocated;

    ;;
    ;; Increment counter
    ;; 
    
    ctx_proposals_seq = seq + 1;

    ;;
    ;; Persist
    ;; 

    store_proposal();
    store_base_data();
}

;;
;; Register vote
;;

() register_vote(int proposalId, int member, int vote) impure {

    ;; Load proposal
    load_proposal(proposalId);

    ;; Check proposal state
    throw_unless(error::invalid_message(), ctx_proposal_state == state::pending());

    ;; Check if already voted
    var (vs, vfound) = ctx_proposal_votes.udict_get?(256, member);
    throw_if(error::invalid_message(), vfound);

    ;; Check if had shares
    var shares = load_shares(ctx_proposal_members, member);
    throw_unless(error::no_voting_power(), shares > 0);

    ;; Register vote
    if (vote == vote::yes()) {
        ctx_proposal_voted_yes = ctx_proposal_voted_yes + shares;
    } elseif (vote == vote::no()) {
        ctx_proposal_voted_no = ctx_proposal_voted_no + shares;
    } elseif (vote == vote::abstain()) {
        ctx_proposal_voted_abstain = ctx_proposal_voted_abstain + shares;
    } else {
        throw(error::invalid_message());
    }
    var changed = udict_set_builder(ctx_proposal_votes, 256, member, begin_cell().store_uint(vote, 2));
    ctx_proposal_votes = changed;

    ;; Check if vote succeeded
    if (ctx_proposal_voted_yes >= ctx_proposal_treshold_success) {
        ctx_proposal_state = state::success();
    }

    ;; Check if vote failed
    if (ctx_proposal_voted_no >= ctx_proposal_treshold_failure) {
        ctx_proposal_state = state::failure();
    }

    ;; Check if vote won't be able to succeed: too many votes against or abstent
    if (ctx_proposal_voted_no + ctx_proposal_voted_abstain > ctx_proposal_members_shares_allocated - ctx_proposal_treshold_success) {
        ctx_proposal_state = state::failure();
    }

    ;; Persist
    store_proposal();
    store_base_data();
}

;;
;; Prepare execution
;;

cell prepare_execute(int proposalId, int member) impure {
    
    ;; Load proposal
    load_proposal(proposalId);

    ;; Check proposal state
    throw_unless(error::invalid_message(), ctx_proposal_state == state::success());

    ;; Check if can execute
    throw_unless(error::invalid_message(), ctx_proposal_author == member);

    ;; Update executed state
    ctx_proposal_state = state::executed();

    ;; Keep reference for proposal body
    cell res = ctx_proposal_body;

    ;; Persist
    store_proposal();
    store_base_data();

    return res;
}

_ get_version() method_id {
    return (0, 0, 2);
}

_ get_last_proposal_id() method_id {
    load_base_data();
    return ctx_proposals_seq - 1;
}

_ get_proposal(int id) method_id {
    load_base_data();
    load_proposal(id);
    
    return (0, 
        ctx_proposal_state, 
        ctx_proposal_voted_yes, 
        ctx_proposal_voted_no, 
        ctx_proposal_voted_abstain, 
        ctx_proposal_body, 
        ctx_proposal_author,
        ctx_proposal_created,
        ctx_proposal_treshold_success,
        ctx_proposal_treshold_failure,
        ctx_proposal_metadata
    );
}

_ get_membership(slice addr) method_id {
    (int sender_wc, slice sender_addr) = parse_var_addr(addr);
    if (sender_wc != 0) {
        return (0, 0);
    }
    int member = sender_addr~load_uint(256);
    load_base_data();
    var shares = load_shares(ctx_members_dict, member);
    if (shares > 0) {
        return (1, shares);
    } else {
        return (0, 0);
    }
}

() op_proposal(int member, int value, slice in_msg, int query_id) impure {

    ;; Check input
    int seq = in_msg~load_uint(32);
    cell proposal = in_msg~load_ref();
    cell metadata = in_msg~load_ref();
    in_msg.end_parse();
    throw_unless(error::invalid_message(), check_proposal(proposal));

    ;; Register input
    register_proposal(seq, proposal, metadata, member);
    send_empty_receipt_message(member, op::proposal::ok(), query_id);
}

() op_vote(int member, int value, slice in_msg, int query_id) impure {
    
    ;; Check input
    int proposalId = in_msg~load_uint(32);
    int vote = in_msg~load_uint(2);
    in_msg.end_parse();

    ;; Register vote
    register_vote(proposalId, member, vote);
    send_empty_receipt_message(member, op::vote::ok(), query_id);
}

() op_execute(int member, int value, slice in_msg, int query_id) impure {

    ;; Check input
    int proposalId = in_msg~load_uint(32);
    in_msg.end_parse();

    ;; Prepare
    var proposal = prepare_execute(proposalId, member);
    send_empty_receipt_message(member, op::execute::ok(), query_id);
    execute_proposal(proposal);
}

() recv_internal(int msg_value, cell in_msg_cell, slice in_msg) impure {

    ;; Prepare message context
    var cs = in_msg_cell.begin_parse();
    var flags = cs~load_uint(4);  ;; int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool
    slice s_addr = cs~load_msg_addr();
    (int sender_wc, slice sender_addr) = parse_var_addr(s_addr);

    ;; Bounced
    ;; DAO accepts all bounced messages in case of invalid 
    ;; message was sent by DAO
    if (flags & 1) {
        return ();
    }

    ;; Ignore messages from non-workchain
    if (sender_wc != 0) {
        return ();
    }

    ;; Load base data
    int member = sender_addr~load_uint(256);
    load_base_data();

    ;; Ignore invalid operations
    if (in_msg.slice_bits() < (32 + 64)) {
        return ();
    }

    ;; Parse operation
    int op = in_msg~load_uint(32);
    int query_id = in_msg~load_uint(64);
    if (op == op::proposal()) {
        op_proposal(member, msg_value, in_msg, query_id);
        return ();
    }
    if (op == op::vote()) {
        op_vote(member, msg_value, in_msg, query_id);
        return ();
    }
    if (op == op::execute()) {
        op_execute(member, msg_value, in_msg, query_id);
        return ();
    }

    ;; Ignore all invalid operations since DAO could vote to return coins to sender
    return ();
}

