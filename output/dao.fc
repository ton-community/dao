;; Commands
int op::proposal() asm "3241702467 PUSHINT";
int op::proposal::ok() asm "2391675301 PUSHINT";
int op::proposal::failed() asm "3508280713 PUSHINT";

int op::vote() asm "3047515073 PUSHINT";
int op::vote::ok() asm "1127259026 PUSHINT";
int op::vote::failed() asm "3486613244 PUSHINT";

int op::execute() asm "2483002579 PUSHINT";
int op::execute::ok() asm "2514550856 PUSHINT";
int op::execute::failed() asm "2163078063 PUSHINT";

;; Proposals
int proposal::transaction() asm "1225918510 PUSHINT";

;; Errors
int error::invalid_address() asm "70 PUSHINT";
int error::invalid_message() asm "72 PUSHINT";
int error::access_denied() asm "73 PUSHINT";
int error::internal_error() asm "74 PUSHINT";
int error::too_low_value() asm "76 PUSHINT";
int error::no_voting_power() asm "77 PUSHINT";

;; State
int vote::yes() asm "1 PUSHINT";
int vote::no() asm "0 PUSHINT";
int vote::abstent() asm "2 PUSHINT";

int state::pending() asm "0 PUSHINT";
int state::success() asm "1 PUSHINT";
int state::failure() asm "2 PUSHINT";
int state::executed() asm "3 PUSHINT";

;;
;; Basic workchain addresses
;;

int parse_work_addr(slice cs) {
  (int sender_wc, slice sender_addr) = parse_var_addr(cs);
  throw_unless(error::invalid_address(), 0 == sender_wc);
  return sender_addr~load_uint(256);
}

(slice) serialize_work_addr(int addr) {
   return (begin_cell()
     .store_uint(2, 2)  ;; Is std address
     .store_uint(0, 1)  ;; Non-unicast
     .store_uint(0, 8)  ;; Basic workchain
     .store_uint(addr, 256) ;; Address hash
   ).end_cell().begin_parse();
}

;;
;; Custom Commands
;;

builder store_coins(builder b, int x) asm "STGRAMS";
(slice, int) load_coins(slice s) asm( -> 1 0) "LDGRAMS";

global int ctx_version;

global int ctx_members_shares_total;
global int ctx_members_shares_allocated;
global int ctx_members_total;
global cell ctx_members_dict;

global int ctx_proposals_seq;
global cell ctx_proposals_dict;
global cell ctx_proposals_ids;

() load_base_data() impure {

    ;; Parse root
    var ds = get_data().begin_parse();
    ctx_version = ds~load_uint(16);
    cell membersRef = ds~load_ref();
    cell proposalsRef = ds~load_ref();
    ds.end_parse();

    ;; Parse members
    ds = membersRef.begin_parse();
    ctx_members_shares_total = ds~load_uint(32);
    ctx_members_shares_allocated = ds~load_uint(32);
    ctx_members_total = ds~load_uint(32);
    ctx_members_dict = ds~load_ref();
    ds.end_parse();

    ;; Parse proposals
    ds = proposalsRef.begin_parse();
    ctx_proposals_seq = ds~load_uint(32);
    ctx_proposals_dict = ds~load_dict();
    ctx_proposals_ids = ds~load_dict();
    ds.end_parse();
}

() store_base_data() impure {
    set_data(begin_cell()
        .store_uint(ctx_version, 16)
        .store_ref(begin_cell()
            .store_uint(ctx_members_shares_total, 32)
            .store_uint(ctx_members_shares_allocated, 32)
            .store_uint(ctx_members_total, 32)
            .store_ref(ctx_members_dict)
        .end_cell())
        .store_ref(begin_cell()
            .store_uint(ctx_proposals_seq, 32)
            .store_dict(ctx_proposals_dict)
            .store_dict(ctx_proposals_ids)
        .end_cell())
    .end_cell());
}

;;
;; Members storage
;; NOTE: this storage have to store ONLY voting shares, do not add anything else here
;;       since it is copied furing proposal creation
;;


int load_shares(cell dict, int member) {
    var (cl, found) = ctx_members_dict.udict_get_ref?(256, member);
    if (found) {
        slice cs = cl.begin_parse();
        int coins = cs~load_coins();
        cs.end_parse();
        return coins;
    } else {
        return 0;
    }
}

cell store_shares(cell dict, int member, int shares) {
    if (shares > 0) {
        var data = begin_cell()
            .store_ref(begin_cell()
                .store_coins(shares)
            .end_cell());
        return udict_set_builder(dict, 256, member, data);
    } else {
        var (changed, _) = udict_delete?(dict, 256, member);
        return changed;
    }
}

{-
cell load_proposals_dict(int id) {
    var (cl, found) = ctx_proposals_ids.udict_get_ref?(8, id);
    if (found) {
        return cl;
    } else {
        return null();
    }
}

cell store_proposals_dict(int id, cell dict) impure {

}

() remove_proposal_ref(int id, int proposal) impure {

    ;; Load proposals collection
    cell d = load_proposals_dict(id);
    if (null?(d)) {
        return ();
    }

    ;; Update dict
    var (changed, ok) = udict_delete?(d, 32, proposal);
    if (ok) {
        store_proposals_dict(id, changed);
    }
}
-}


;;
;; Checks proposal body
;;

int check_proposal(cell proposal) {
    slice cs = proposal.begin_parse();
    int kind = cs~load_uint(32);
    int hasExtras = cs~load_int(1);
    if (hasExtras) {
        return false; ;; Not supported
    }
    if (kind == proposal::transaction()) {
        cs~load_msg_addr(); ;; Load target
        cs~load_coins(); ;; Load coins
        ;; Load maybe stateinit
        if (cs~load_int(1)) {
            cs~load_ref();
        }
        ;; Load maybe payload
        if (cs~load_int(1)) {
            cs~load_ref();
        }
        cs.end_parse();
        return true;
    } else {
        return false;
    }
}

;;
;; Proposal execution
;; NOTE: execution silently fails on invalid proposal to mark proposal as executed instead of crashing transactions
;;       but execution fails if something is wrong
;;

() execute_proposal(cell proposal) impure {

    ;; Begin parsing
    slice cs = proposal.begin_parse();
    int kind = cs~load_uint(32);
    if (cs~load_int(1)) {
        cs~load_ref();
    }

    ;; Tansaction
    if (kind == proposal::transaction()) {

        ;; Basic message
        slice to_addr = cs~load_msg_addr();
        int value = cs~load_coins();
        var msg = begin_cell()
            .store_uint(0x10, 6)
            .store_slice(to_addr)
            .store_coins(value)
            .store_uint(0, 1 + 4 + 4 + 64 + 32);

        ;; State init
        if (cs~load_int(1)) {
            var stateInit = cs~load_ref();
            msg = msg.store_uint(1, 1);
            msg = msg.store_ref(stateInit);
        } else {
            msg = msg.store_uint(0, 1);
        }

        ;; Payload
        if (cs~load_int(1)) {
            var payload = cs~load_ref();
            msg = msg.store_uint(1, 1);
            msg = msg.store_ref(payload);
        } else {
            msg = msg.store_uint(0, 1);
        }

        ;; Send message
        send_raw_message(msg.end_cell(), 2);
    }
}

;;
;; Tresholds
;;

int get_success_treshold(int total) {
    return (total * 51) / 100;
}

int get_fail_treshold(int total) {
    return (total * 25) / 100;
}

;;
;; Register proposal
;;

() register_proposal(int seq, cell proposal, int member) impure {

    ;; Load shares
    int shares = load_shares(ctx_members_dict, member);
    throw_unless(error::no_voting_power(), shares > 0);

    ;; Check seq
    throw_unless(error::invalid_message(), seq == ctx_proposals_seq);

    ;; Resolve state
    int state = state::pending();
    int treshold_success = get_success_treshold(ctx_members_shares_allocated);
    int treshold_failure = get_success_treshold(ctx_members_shares_total);
    if (shares >= treshold_success) {
        state = state::success();
    }
    
    ;; Default vote
    cell votes = null();
    votes~udict_set_builder(256, member, begin_cell().store_uint(vote::yes(), 2));

    ;; Create proposal container
    builder container = begin_cell()
        .store_uint(0, 1) ;; Version
        .store_uint(state, 4) ;; State
        .store_coins(shares) ;; Voted yes
        .store_coins(0) ;; Voted no
        .store_coins(0) ;; Voted abstent
        .store_ref(begin_cell()
            .store_uint(member, 256)
            .store_coins(treshold_success)
            .store_coins(treshold_failure)
        .end_cell())
        .store_ref(votes)
        .store_ref(proposal)
        .store_ref(begin_cell() ;; Shares and membership state on time of proposal
            .store_coins(ctx_members_shares_total)
            .store_coins(ctx_members_shares_allocated)
            .store_coins(ctx_members_total)
            .store_ref(ctx_members_dict)
        .end_cell());

    ;; Register proposal
    cell changed = udict_set_builder(ctx_proposals_dict, 32, seq, container);
    ctx_proposals_dict = changed;
    ctx_proposals_seq = seq + 1;

    ;; Persist
    store_base_data();
}

;;
;; Register vote
;;

() register_vote(int proposalId, int member, int vote) impure {

    ;; Load proposal
    var (cs, found) = ctx_proposals_dict.udict_get?(32, proposalId);
    throw_unless(error::invalid_message(), found);

    ;; Load data
    int version = cs~load_uint(1);
    int state = cs~load_uint(4);
    int voted_yes = cs~load_coins();
    int voted_no = cs~load_coins();
    int voted_abstent = cs~load_coins();
    cell paramsCell = cs~load_ref();
    cell votes = cs~load_ref();
    cell proposal = cs~load_ref();
    cell membersCell = cs~load_ref();
    cs.end_parse();
    
    ;; Params
    cs = paramsCell.begin_parse();
    int author = cs~load_uint(256);
    int treshold_success = cs~load_coins();
    int treshold_failure = cs~load_coins();
    cs.end_parse();

    ;; Members
    cs = membersCell.begin_parse();
    int shares_total = cs~load_coins();
    int shares_allocated = cs~load_coins();
    int members_total = cs~load_coins();
    cell members = cs~load_ref();
    cs.end_parse();

    ;; Check proposal state
    throw_unless(error::invalid_message(), state == state::pending());

    ;; Check if already voted
    var (vs, vfound) = votes.udict_get?(256, member);
    throw_if(vfound, error::invalid_message());

    ;; Check if had shares
    var shares = load_shares(members, member);
    throw_unless(error::no_voting_power(), shares > 0);

    ;; Register vote
    if (vote == vote::yes()) {
        voted_yes = voted_yes + shares;
    } elseif (vote == vote::no()) {
        voted_no = voted_no + shares;
    } elseif (vote == vote::abstent()) {
        voted_abstent = voted_abstent + shares;
    } else {
        throw(error::invalid_message());
    }
    votes~udict_set_builder(256, member, begin_cell().store_uint(vote, 2));

    ;; Check if vote succeeded
    if (voted_yes >= treshold_success) {
        state = state::success();
    }

    ;; Check if vote failed
    if (voted_no >= treshold_failure) {
        state = state::failure();
    }

    ;; Check if vote won't be able to succeed: too many votes against or abstent
    if (voted_no + voted_abstent > shares_allocated - treshold_success) {
        state = state::failure();
    }

    ;; Update proposal
    builder container = begin_cell()
        .store_uint(version, 1)
        .store_uint(state, 4)
        .store_coins(voted_yes)
        .store_coins(voted_no)
        .store_coins(voted_abstent)
        .store_ref(paramsCell)
        .store_ref(votes)
        .store_ref(proposal)
        .store_ref(members);

    ;; Register proposal
    cell changed = udict_set_builder(ctx_proposals_dict, 32, proposalId, container);
    ctx_proposals_dict = changed;

    ;; Persist
    store_base_data();
}

_ get_version() method_id {
    return (0, 0, 1);
}

_ get_last_proposal_id() method_id {
    load_base_data();
    return ctx_proposals_seq - 1;
}

_ get_proposal(int id) method_id {
    load_base_data();
    var (cs, found) = ctx_proposals_dict.udict_get?(32, id);
    throw_unless(error::invalid_message(), found);

    ;; Parse basic
    int version = cs~load_uint(1);
    int state = cs~load_uint(4);
    int voted_yes = cs~load_coins();
    int voted_no = cs~load_coins();
    int voted_abstent = cs~load_coins();
    cell paramsCell = cs~load_ref();
    cell votes = cs~load_ref();
    cell proposal = cs~load_ref();
    cell membersCell = cs~load_ref();
    cs.end_parse();

    return (version, state, voted_yes, voted_no, voted_abstent, proposal, paramsCell);
}

() op_proposal(int member, int value, slice in_msg) impure {

    ;; Check input
    int seq = in_msg~load_uint(32);
    cell proposal = in_msg~load_ref();
    in_msg.end_parse();
    throw_unless(error::invalid_message(), check_proposal(proposal));

    ;; Register input
    register_proposal(seq, proposal, member);
}

() op_vote(int member, int value, slice in_msg) impure {
    
    ;; Check input
    int proposalId = in_msg~load_uint(32);
    int vote = in_msg~load_uint(2);
    in_msg.end_parse();

    ;; Register vote
    register_vote(proposalId, member, vote);
}

() op_execute(int member, int value, slice in_msg) impure {
    
}

() recv_internal(int msg_value, cell in_msg_cell, slice in_msg) impure {

    ;; Prepare message context
    var cs = in_msg_cell.begin_parse();
    var flags = cs~load_uint(4);  ;; int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool
    slice s_addr = cs~load_msg_addr();
    (int sender_wc, slice sender_addr) = parse_var_addr(s_addr);

    ;; Bounced
    ;; DAO accepts all bounced messages in case of invalid 
    ;; message was sent by DAO
    if (flags & 1) {
        return ();
    }

    ;; Ignore messages from non-workchain
    if (sender_wc != 0) {
        return ();
    }

    ;; Load base data
    int member = sender_addr~load_uint(256);
    load_base_data();

    ;; Ignore invalid operations
    if (in_msg.slice_bits() < 32) {
        return ();
    }

    ;; Parse operation
    int op = in_msg~load_uint(32);
    if (op == op::proposal()) {
        op_proposal(member, msg_value, in_msg);
        return ();
    }
    if (op == op::vote()) {
        op_vote(member, msg_value, in_msg);
        return ();
    }
    if (op == op::execute()) {
        op_execute(member, msg_value, in_msg);
        return ();
    }

    ;; Ignore all invalid operations since DAO could vote to return coins to sender
    return ();
}

() recv_external(slice in_msg) impure {
    ;; Do not accept external messages
    throw(error::invalid_message());
}

